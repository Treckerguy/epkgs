(:summary    "Additions to shell mode for use with kermit"
 :created    "19880215"
 :updated    "2011"
 :license    "GPL-3"
 :authors    (("Jeff Norden" . "jeff@colgate.csnet"))
 :maintainer ("FSF")
 :provided   (kermit)
 :required   ((("shell" shell)))
 :keywords   ("comm")
 :commentary "\
I'm not sure, but I think somebody asked about running kermit under shell
mode a while ago.  Anyway, here is some code that I find useful.  The result
is that I can log onto machines with primitive operating systems (VMS and
ATT system V :-), and still have the features of shell-mode available for
command history, etc.  It's also handy to be able to run a file transfer in
an emacs window.  The transfer is in the \"background\", but you can also
monitor or stop it easily.

The ^\\ key is bound to a function for sending escape sequences to kermit,
and ^C^Q can be used to send any control characters needed thru to the
system you connect to.  A more serious problem is that some brain-dead
systems will not recognize a ^J as an end-of-line character.  So LFD is
bound to a new function which acts just like CR usually does in shell-mode,
but a ^M is sent as an end-of-line.  Functions are also provided to swap the
bindings of CR and LFD.  I've also included a filter which will clean out
any ^M's or ^@'s that get typed at you, but I don't really recommend it.
There doesn't seem to be an acceptably fast way to do this via emacs-lisp.
Invoking kermit by the command \" kermit | tr -d '\\015' \" seems to work
better (on my system anyway).

Here's how I've been using this setup.  We have several machines connected
thru a fairly stupid terminal switch.  If I want to connect to unix system,
then I use the LFD key to talk to the switch, and ignore any ^M's in the
buffer, and do a \" stty -echo nl \" after I log in.  Then the only real
difference from being in local shell-mode is that you need to type
^C^Q^C to send an interrupt, and ^C^Q^Z for a stop signal, etc.  (since ^C^C
just generates a local stop signal, which kermit ignores).
To connect to a VMS system, I use a shell script to invoke kermit thru the
tr filter, do \"M-X kermit-send-cr\", and then tell VMS that I'm on a
half-duplex terminal.

Some caveats:
1) Kermit under shell mode is a real pain if you don't have pty's.  I
recently discovered this on our 3b2/400.  When kermit can't find a tty, it
assumes it is supposed to be in remote mode.  So the simple command \"kermit\"
won't work in shell mode on such a system.  You can get around this by using
the -c (connect) command line option, which means you also have to specify a
line and baud on the command line, as in \"kermit -l /dev/tty53 -b 9600 -c\".
However, this will cause kermit to exit when the connection is closed.  So
in order to do a file transfer, you have to think ahead and and add -r
(receive) to the command line.  This means that you can't use the server
feature.  The only fix I can see is to muck around with the source code for
kermit, although this probably wouldn't be too hard.  What is needed is an
option to force kermit to be local, to use stdin and stdout for interactive
speech, and to forget about cbreak mode.

Please let me know if any bugs turn up.
Feb 1988, Jeff Norden - jeff@colgate.csnet")
