(:summary    "Symbolic regular expressions"
 :created    "1997"
 :updated    "2011"
 :license    "GPL-3"
 :authors    (("Bob Glickstein" . "bobg+sregex@zanshin.com"))
 :maintainer ("Bob Glickstein" . "bobg+sregex@zanshin.com")
 :provided   (sregex)
 :required   ((("cl" cl)))
 :keywords   (extensions)
 :commentary "\
This package allows you to write regular expressions using a
totally new, Lisp-like syntax.

A \"symbolic regular expression\" (sregex for short) is a Lisp form
that, when evaluated, produces the string form of the specified
regular expression.  Here's a simple example:

  (sregexq (or \"Bob\" \"Robert\"))  =>  \"Bob\\\\|Robert\"

As you can see, an sregex is specified by placing one or more
special clauses in a call to `sregexq'.  The clause in this case is
the `or' of two strings (not to be confused with the Lisp function
`or').  The list of allowable clauses appears below.

With sregex, it is never necessary to \"escape\" magic characters
that are meant to be taken literally; that happens automatically.
For example:

  (sregexq \"M*A*S*H\")  =>  \"M\\\\*A\\\\*S\\\\*H\"

It is also unnecessary to \"group\" parts of the expression together
to overcome operator precedence; that also happens automatically.
For example:

  (sregexq (opt (or \"Bob\" \"Robert\")))  =>  \"\\\\(?:Bob\\\\|Robert\\\\)?\"

It *is* possible to group parts of the expression in order to refer
to them with numbered backreferences:

  (sregexq (group (or \"Go\" \"Run\"))
           \", Spot, \"
           (backref 1))             =>  \"\\\\(Go\\\\|Run\\\\), Spot, \\\\1\"

`sregexq' is a macro.  Each time it is used, it constructs a simple
Lisp expression that then invokes a moderately complex engine to
interpret the sregex and render the string form.  Because of this,
I don't recommend sprinkling calls to `sregexq' throughout your
code, the way one normally does with string regexes (which are
cheap to evaluate).  Instead, it's wiser to precompute the regexes
you need wherever possible instead of repeatedly constructing the
same ones over and over.  Example:

   (let ((field-regex (sregexq (opt \"resent-\")
                               (or \"to\" \"cc\" \"bcc\"))))
     ...
     (while ...
       ...
       (re-search-forward field-regex ...)
       ...))

The arguments to `sregexq' are automatically quoted, but the
flipside of this is that it is not straightforward to include
computed (i.e., non-constant) values in `sregexq' expressions.  So
`sregex' is a function that is like `sregexq' but which does not
automatically quote its values.  Literal sregex clauses must be
explicitly quoted like so:

  (sregex '(or \"Bob\" \"Robert\"))  =>  \"Bob\\\\|Robert\"

but computed clauses can be included easily, allowing for the reuse
of common clauses:

 (let ((dotstar '(0+ any))
       (whitespace '(1+ (syntax ?-)))
       (digits '(1+ (char (?0 . ?9)))))
   (sregex 'bol dotstar \":\" whitespace digits))  =>  \"^.*:\\\\s-+[0-9]+\"

To use this package in a Lisp program, simply (require 'sregex).

Here are the clauses allowed in an `sregex' or `sregexq'
expression:

- a string
  This stands for the literal string.  If it contains
  metacharacters, they will be escaped in the resulting regex
  (using `regexp-quote').

- the symbol `any'
  This stands for \".\", a regex matching any character except
  newline.

- the symbol `bol'
  Stands for \"^\", matching the empty string at the beginning of a line

- the symbol `eol'
  Stands for \"$\", matching the empty string at the end of a line

- (group CLAUSE ...)
  Groups the given CLAUSEs using \"\\\\(\" and \"\\\\)\".

- (sequence CLAUSE ...)

  Groups the given CLAUSEs; may or may not use \"\\\\(?:\" and \"\\\\)\".
  Clauses grouped by `sequence' do not count for purposes of
  numbering backreferences.  Use `sequence' in situations like
  this:

    (sregexq (or \"dog\" \"cat\"
                 (sequence (opt \"sea \") \"monkey\")))
                                 =>  \"dog\\\\|cat\\\\|\\\\(?:sea \\\\)?monkey\"

  where a single `or' alternate needs to contain multiple
  subclauses.

- (backref N)
  Matches the same string previously matched by the Nth \"group\" in
  the same sregex.  N is a positive integer.

- (or CLAUSE ...)
  Matches any one of the CLAUSEs by separating them with \"\\\\|\".

- (0+ CLAUSE ...)
  Concatenates the given CLAUSEs and matches zero or more
  occurrences by appending \"*\".

- (1+ CLAUSE ...)
  Concatenates the given CLAUSEs and matches one or more
  occurrences by appending \"+\".

- (opt CLAUSE ...)
  Concatenates the given CLAUSEs and matches zero or one occurrence
  by appending \"?\".

- (repeat MIN MAX CLAUSE ...)
  Concatenates the given CLAUSEs and constructs a regex matching at
  least MIN occurrences and at most MAX occurrences.  MIN must be a
  non-negative integer.  MAX must be a non-negative integer greater
  than or equal to MIN; or MAX can be nil to mean \"infinity.\"

- (char CHAR-CLAUSE ...)
  Creates a \"character class\" matching one character from the given
  set.  See below for how to construct a CHAR-CLAUSE.

- (not-char CHAR-CLAUSE ...)
  Creates a \"character class\" matching any one character not in the
  given set.  See below for how to construct a CHAR-CLAUSE.

- the symbol `bot'
  Stands for \"\\\\`\", matching the empty string at the beginning of
  text (beginning of a string or of a buffer).

- the symbol `eot'
  Stands for \"\\\\'\", matching the empty string at the end of text.

- the symbol `point'
  Stands for \"\\\\=\", matching the empty string at point.

- the symbol `word-boundary'
  Stands for \"\\\\b\", matching the empty string at the beginning or
  end of a word.

- the symbol `not-word-boundary'
  Stands for \"\\\\B\", matching the empty string not at the beginning
  or end of a word.

- the symbol `bow'
  Stands for \"\\\\<\", matching the empty string at the beginning of a
  word.

- the symbol `eow'
  Stands for \"\\\\>\", matching the empty string at the end of a word.

- the symbol `wordchar'
  Stands for the regex \"\\\\w\", matching a word-constituent character
  (as determined by the current syntax table)

- the symbol `not-wordchar'
  Stands for the regex \"\\\\W\", matching a non-word-constituent
  character.

- (syntax CODE)
  Stands for the regex \"\\\\sCODE\", where CODE is a syntax table code
  (a single character).  Matches any character with the requested
  syntax.

- (not-syntax CODE)
  Stands for the regex \"\\\\SCODE\", where CODE is a syntax table code
  (a single character).  Matches any character without the
  requested syntax.

- (regex REGEX)
  This is a \"trapdoor\" for including ordinary regular expression
  strings in the result.  Some regular expressions are clearer when
  written the old way: \"[a-z]\" vs. (sregexq (char (?a . ?z))), for
  instance.  However, see the note under \"Bugs,\" below.

Each CHAR-CLAUSE that is passed to (char ...) and (not-char ...)
has one of the following forms:

- a character
  Adds that character to the set.

- a string
  Adds all the characters in the string to the set.

- A pair (MIN . MAX)
  Where MIN and MAX are characters, adds the range of characters
  from MIN through MAX to the set.")
