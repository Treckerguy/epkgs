(:summary    "Simple Minded Indentation Engine"
 :created    "2010"
 :updated    "2011"
 :license    "GPL-3"
 :authors    (("Stefan Monnier" . "monnier@iro.umontreal.ca"))
 :maintainer ("Stefan Monnier" . "monnier@iro.umontreal.ca")
 :provided   (smie)
 :required   ((("cl" cl)))
 :keywords   ("languages" "lisp" "internal" "parsing" "indentation")
 :commentary "\
While working on the SML indentation code, the idea grew that maybe
I could write something generic to do the same thing, and at the
end of working on the SML code, I had a pretty good idea of what it
could look like.  That idea grew stronger after working on
LaTeX indentation.

So at some point I decided to try it out, by writing a new
indentation code for Coq while trying to keep most of the code
\"table driven\", where only the tables are Coq-specific.  The result
(which was used for Beluga-mode as well) turned out to be based on
something pretty close to an operator precedence parser.

So here is another rewrite, this time following the actual principles of
operator precedence grammars.  Why OPG?  Even though they're among the
weakest kinds of parsers, these parsers have some very desirable properties
for Emacs:
- most importantly for indentation, they work equally well in either
  direction, so you can use them to parse backward from the indentation
  point to learn the syntactic context;
- they work locally, so there's no need to keep a cache of
  the parser's state;
- because of that locality, indentation also works just fine when earlier
  parts of the buffer are syntactically incorrect since the indentation
  looks at \"as little as possible\" of the buffer to make an indentation
  decision.
- they typically have no error handling and can't even detect a parsing
  error, so we don't have to worry about what to do in case of a syntax
  error because the parser just automatically does something.  Better yet,
  we can afford to use a sloppy grammar.

A good background to understand the development (especially the parts
building the 2D precedence tables and then computing the precedence levels
from it) can be found in pages 187-194 of \"Parsing techniques\" by Dick Grune
and Ceriel Jacobs (BookBody.pdf available at
http://www.cs.vu.nl/~dick/PTAPG.html).

OTOH we had to kill many chickens, read many coffee grounds, and practice
untold numbers of black magic spells, to come up with the indentation code.
Since then, some of that code has been beaten into submission, but the
smie-indent-keyword is still pretty obscure.

Conflict resolution:

- One source of conflicts is when you have:
    (exp (\"IF\" exp \"ELSE\" exp \"END\") (\"CASE\" cases \"END\"))
    (cases (cases \"ELSE\" insts) ...)
  The IF-rule implies ELSE=END and the CASE-rule implies ELSE>END.
  FIXME: we could try to resolve such conflicts automatically by changing
  the way BNF rules such as the IF-rule is handled.  I.e. rather than
  IF=ELSE and ELSE=END, we could turn them into IF<ELSE and ELSE>END
  and IF=END,

TODO & BUGS:

- Using the structural information SMIE gives us, it should be possible to
  implement a `smie-align' command that would automatically figure out what
  there is to align and how to do it (something like: align the token of
  lowest precedence that appears the same number of times on all lines,
  and then do the same on each side of that token).
- Maybe accept two juxtaposed non-terminals in the BNF under the condition
  that the first always ends with a terminal, or that the second always
  starts with a terminal.")
