(:summary    "Emacs Lisp Profiler"
 :created    "1994"
 :updated    "2011"
 :license    "GPL-3"
 :authors    (("Barry A. Warsaw"))
 :maintainer ("FSF")
 :provided   (elp)
 :keywords   ("debugging" "lisp" "tools")
 :homepage   "http://www.python.org/emacs/"
 :commentary "\
If you want to profile a bunch of functions, set elp-function-list
to the list of symbols, then do a M-x elp-instrument-list.  This
hacks those functions so that profiling information is recorded
whenever they are called.  To print out the current results, use
M-x elp-results.  If you want output to go to standard-output
instead of a separate buffer, setq elp-use-standard-output to
non-nil.  With elp-reset-after-results set to non-nil, profiling
information will be reset whenever the results are displayed.  You
can also reset all profiling info at any time with M-x
elp-reset-all.

You can also instrument all functions in a package, provided that
the package follows the GNU coding standard of a common textual
prefix.  Use M-x elp-instrument-package for this.

If you want to sort the results, set elp-sort-by-function to some
predicate function.  The three most obvious choices are predefined:
elp-sort-by-call-count, elp-sort-by-average-time, and
elp-sort-by-total-time.  Also, you can prune from the output, all
functions that have been called fewer than a given number of times
by setting elp-report-limit.

Elp can instrument byte-compiled functions just as easily as
interpreted functions, but it cannot instrument macros.  However,
when you redefine a function (e.g. with eval-defun), you'll need to
re-instrument it with M-x elp-instrument-function.  This will also
reset profiling information for that function.  Elp can handle
interactive functions (i.e. commands), but of course any time spent
idling for user prompts will show up in the timing results.

You can also designate a `master' function.  Profiling times will
be gathered for instrumented functions only during execution of
this master function.  Thus, if you have some defuns like:

 (defun foo () (do-something-time-intensive))
 (defun bar () (foo))
 (defun baz () (bar) (foo))

and you want to find out the amount of time spent in bar and foo,
but only during execution of bar, make bar the master.  The call of
foo from baz will not add to foo's total timing sums.  Use M-x
elp-set-master and M-x elp-unset-master to utilize this feature.
Only one master function can be set at a time.

You can restore any function's original function definition with
elp-restore-function.  The other instrument, restore, and reset
functions are provided for symmetry.

Here is a list of variable you can use to customize elp:
  elp-function-list
  elp-reset-after-results
  elp-sort-by-function
  elp-report-limit

Here is a list of the interactive commands you can use:
  elp-instrument-function
  elp-restore-function
  elp-instrument-list
  elp-restore-list
  elp-instrument-package
  elp-restore-all
  elp-reset-function
  elp-reset-list
  elp-reset-all
  elp-set-master
  elp-unset-master
  elp-results

Note that there are plenty of factors that could make the times
reported unreliable, including the accuracy and granularity of your
system clock, and the overhead spent in lisp calculating and
recording the intervals.  I figure the latter is pretty constant,
so while the times may not be entirely accurate, I think they'll
give you a good feel for the relative amount of work spent in the
various lisp routines you are profiling.  Note further that times
are calculated using wall-clock time, so other system load will
affect accuracy too.")
