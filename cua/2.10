(:summary    "Emulate CUA key bindings"
 :created    "2001"
 :updated    "2001"
 :license    "GPL-2"
 :authors    (("Kim F. Storm" . "storm@cua.dk"))
 :maintainer ("Kim F. Storm" . "storm@cua.dk")
 :provided   (CUA-mode cua cua-mode)
 :required   ((("emacs" custom iso-transl rect timer)))
 :keywords   ("keyboard" "cua")
 :homepage   "http://www.cua.dk/cua.html"
 :wikipage   "http://www.emacswiki.org/CuaMode"
 :commentary "\
This is the CUA-mode package which provides a complete emulation of
the standard CUA key bindings (Motif/Windows/Mac GUI) for selecting
and manipulating the region where S-<movement> is used to
highlight & extend the region.

This package allow the C-z, C-x, C-c, and C-v keys to be
bound appropriately according to the Motif/Windows GUI, i.e.
	C-z	-> undo
	C-x	-> cut
	C-c	-> copy
	C-v	-> paste

The tricky part is the handling of the C-x and C-c keys which
are normally used as prefix keys for most of emacs' built-in
commands.  With CUA-mode they still do!!!

Only when the region is currently active (and highlighted since
transient-mark-mode is used), the C-x and C-c keys will work as CUA
keys
	C-x -> cut
	C-c -> copy
When the region is not active, C-x and C-c works as prefix keys!

This probably sounds strange and difficult to get used to - but
based on my own experience and the feedback from many users of
CUA-mode, it actually works very well and users adapt to it
instantly - or at least very quickly.  So give it a try!  
... and in the few cases where you make a mistake and accidentally
delete the region - you just undo the mistake (with C-z).

If you really need to perform a command which starts with one of
the prefix keys even when the region is active, you have three options:
- press the prefix key twice very quickly (within 0.2 seconds),
- press the prefix key and the following key within 0.2 seconds), or
- use the SHIFT key with the prefix key, i.e. C-X or C-C

This behaviour is controlled via the CUA-mode-inhibit-method and
CUA-mode-inhibit-delay variables. 

In addition to using the shifted movement keys, you can also use
[C-space] to start the region and use unshifted movement keys to extend
it. To cancel the region, use [C-space] or [C-g].

If you want to take advantage of CUA-mode's superior rectangle
support and uniform bindings, but prefer to use the standard
emacs cut, copy, paste, and undo bindings, set the variable
CUA-mode-emacs-bindings to t before the call to CUA-mode.


New features

With release 2 of the CUA-mode package, the CUA commands have been
extended to handle both rectangles and registers in a homogeneous
manner, as well as adding the concept of a \"global mark\" as
described below.

CUA rectangle support

Emacs' normal rectangle support is based on interpreting the region
between the mark and point as a \"virtual rectangle\", and using a
completely separate set of \"rectangle commands\" [C-x r ...] on the
region to copy, kill, fill a.s.o. the virtual rectangle.

CUA-mode's superior rectangle support is based on using a true visual
representation of the selected rectangle. To start a rectangle, use
[S-return] and extend it using the normal movement keys (up, down,
left, right, home, end, C-home, C-end). Once the rectangle has the
desired size, you can cut or copy it using C-x and C-c, and you can
subsequently insert it - as a rectangle - using C-v.  So the only new
command you need to know to work with CUA-mode rectangles is S-return!

Furthermore, CUA-mode's rectangles are not limited to the actual
contents of the buffer, so if the cursor is currently at the end of a
short line, you can still extend the rectangle to include more columns
of longer lines in the same rectangle.  Sounds strange? Try it!

You can enable padding for just this rectangle by pressing [M-p];
this works like entering 'picture mode' where the tabs and spaces
are automatically converted/inserted to make the rectangle truly
rectangular. Or you can do it for all rectangles by setting the
CUA-mode-auto-expand-rectangles variable to 'yes.

And there's more: If you want to extend or reduce the size of the
rectangle in one of the other corners of the rectangle, just use
[return] to move the cursor to the \"next\" corner.  Or you can use
the [M-up], [M-down], [M-left], and [M-right] keys to move the
entire rectangle overlay (but not the contents) in the given
direction.

[S-return] cancels the rectangle
[C-space] activate region bounded by rectangle

If you type a normal (self-inserting) character when the rectangle is
active, the character is inserted on the \"current side\" of every line
of the rectangle.  The \"current side\" is the side on which the cursor
is currently located. If the rectangle is only 1 column wide,
insertion will be performed to the left when the cursor is at the
bottom of the rectangle.  So, for example, to comment out an entire
paragraph like this one, just place the cursor on the first character
of the first line, and enter the following:
    [S-return] [down].... [;; ] [S-return]")
