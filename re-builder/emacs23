(:summary    "Building Regexps with visual feedback"
 :created    "1999"
 :updated    "2011"
 :license    "GPL-3"
 :authors    (("Detlev Zundel" . "dzu@gnu.org"))
 :maintainer ("Detlev Zundel" . "dzu@gnu.org")
 :provided   (re-builder)
 :required   ((("emacs-core" overlay)
	       ("rx" rx)
	       ("sregex" sregex)
	       (nil lisp-re)))
 :keywords   ("matching" "lisp" "tools")
 :wikipage   "http://www.emacswiki.org/ReBuilder"
 :commentary "\
When I have to come up with regular expressions that are more
complex than simple string matchers, especially if they contain sub
expressions, I find myself spending quite some time in the
`development cycle'.  `re-builder' aims to shorten this time span
so I can get on with the more interesting bits.

With it you can have immediate visual feedback about how well the
regexp behaves to your expectations on the intended data.

When called up `re-builder' attaches itself to the current buffer
which becomes its target buffer, where all the matching is done.
The active window is split so you have a view on the data while
authoring the RE.  If the edited expression is valid the matches in
the target buffer are marked automatically with colored overlays
(for non-color displays see below) giving you feedback over the
extents of the matched (sub) expressions.  The (non-)validity is
shown only in the modeline without throwing the errors at you.  If
you want to know the reason why RE Builder considers it as invalid
call `reb-force-update' (\"\\C-c\\C-u\") which should reveal the error.

The target buffer can be changed with `reb-change-target-buffer'
(\"\\C-c\\C-b\").  Changing the target buffer automatically removes
the overlays from the old buffer and displays the new one in the
target window.

The `re-builder' keeps the focus while updating the matches in the
target buffer so corrections are easy to incorporate.  If you are
satisfied with the result you can paste the RE to the kill-ring
with `reb-copy' (\"\\C-c\\C-w\"), quit the `re-builder' (\"\\C-c\\C-q\")
and use it wherever you need it.

As the automatic updates can take some time on large buffers, they
can be limited by `reb-auto-match-limit' so that they should not
have a negative impact on the editing.  Setting it to nil makes
even the auto updates go all the way.  Forcing an update overrides
this limit allowing an easy way to see all matches.

Currently `re-builder' understands five different forms of input,
namely `read', `string', `rx', `sregex' and `lisp-re' syntax.  Read
syntax and string syntax are both delimited by `\"'s and behave
according to their name.  With the `string' syntax there's no need
to escape the backslashes and double quotes simplifying the editing
somewhat.  The other three allow editing of symbolic regular
expressions supported by the packages of the same name.  (`lisp-re'
is a package by me and its support may go away as it is nearly the
same as the `sregex' package in Emacs)

Editing symbolic expressions is done through a major mode derived
from `emacs-lisp-mode' so you'll get all the good stuff like
automatic indentation and font-locking etc.

When editing a symbolic regular expression, only the first
expression in the RE Builder buffer is considered, which helps
limiting the extent of the expression like the `\"'s do for the text
modes.  For the `sregex' syntax the function `sregex' is applied to
the evaluated expression read.  So you can use quoted arguments
with something like '(\"findme\") or you can construct arguments to
your hearts delight with a valid ELisp expression.  (The compiled
string form will be copied by `reb-copy')  If you want to take
a glance at the corresponding string you can temporarily change the
input syntax.

Changing the input syntax is transparent (for the obvious exception
non-symbolic -> symbolic) so you can change your mind as often as
you like.

There is also a shortcut function for toggling the
`case-fold-search' variable in the target buffer with an immediate
update.


Q: But what if my display cannot show colored overlays?
A: Then the cursor will flash around the matched text making it stand
   out.

Q: But how can I then make out the sub-expressions?
A: Thats where the `sub-expression mode' comes in.  In it only the
   digit keys are assigned to perform an update that will flash the
   corresponding subexp only.")
