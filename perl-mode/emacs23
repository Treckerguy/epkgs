(:summary    "Perl code editing commands for GNU Emacs"
 :created    "1990"
 :updated    "2011"
 :license    "GPL-3"
 :authors    (("William F. Mann"))
 :maintainer ("FSF")
 :adapted-by ("ESR")
 :provided   (perl-mode)
 :required   ((("cl" cl)))
 :keywords   ("languages")
 :wikipage   "http://www.emacswiki.org/PerlMode"
 :commentary "\
To enter perl-mode automatically, add (autoload 'perl-mode \"perl-mode\")
to your .emacs file and change the first line of your perl script to:
#!/usr/bin/perl --	 # -*-Perl-*-
With arguments to perl:
#!/usr/bin/perl -P-	 # -*-Perl-*-
To handle files included with do 'filename.pl';, add something like
(setq auto-mode-alist (append (list (cons \"\\\\.pl\\\\'\" 'perl-mode))
                              auto-mode-alist))
to your .emacs file; otherwise the .pl suffix defaults to prolog-mode.

This code is based on the 18.53 version c-mode.el, with extensive
rewriting.  Most of the features of c-mode survived intact.

I added a new feature which adds functionality to TAB; it is controlled
by the variable perl-tab-to-comment.  With it enabled, TAB does the
first thing it can from the following list:  change the indentation;
move past leading white space; delete an empty comment; reindent a
comment; move to end of line; create an empty comment; tell you that
the line ends in a quoted string, or has a # which should be a \\#.

If your machine is slow, you may want to remove some of the bindings
to perl-electric-terminator.  I changed the indenting defaults to be
what Larry Wall uses in perl/lib, but left in all the options.

I also tuned a few things:  comments and labels starting in column
zero are left there by perl-indent-exp; perl-beginning-of-function
goes back to the first open brace/paren in column zero, the open brace
in 'sub ... {', or the equal sign in 'format ... ='; perl-indent-exp
(meta-^q) indents from the current line through the close of the next
brace/paren, so you don't need to start exactly at a brace or paren.

It may be good style to put a set of redundant braces around your
main program.  This will let you reindent it with meta-^q.

Known problems (these are all caused by limitations in the Emacs Lisp
parsing routine (parse-partial-sexp), which was not designed for such
a rich language; writing a more suitable parser would be a big job):
2)  The globbing syntax <pattern> is not recognized, so special
      characters in the pattern string must be backslashed.
3)  The << quoting operators are not recognized; see below.
5)  To make '$' work correctly, $' is not recognized as a variable.
    Use \"$'\" or $POSTMATCH instead.

If you don't use font-lock, additional problems will appear:
1)  Regular expression delimiters do not act as quotes, so special
      characters such as `'\"#:;[](){} may need to be backslashed
      in regular expressions and in both parts of s/// and tr///.
4)  The q and qq quoting operators are not recognized; see below.
5)  To make variables such a $' and $#array work, perl-mode treats
      $ just like backslash, so '$' is not treated correctly.
6)  Unfortunately, treating $ like \\ makes ${var} be treated as an
      unmatched }.  See below.
7)  When ' (quote) is used as a package name separator, perl-mode
      doesn't understand, and thinks it is seeing a quoted string.

Here are some ugly tricks to bypass some of these problems:  the perl
expression /`/ (that's a back-tick) usually evaluates harmlessly,
but will trick perl-mode into starting a quoted string, which
can be ended with another /`/.  Assuming you have no embedded
back-ticks, this can used to help solve problem 3:

    /`/; $ugly = q?\"'$?; /`/;

The same trick can be used for problem 6 as in:
    /{/; while (<${glob_me}>)
but a simpler solution is to add a space between the $ and the {:
    while (<$ {glob_me}>)

Problem 7 is even worse, but this 'fix' does work :-(
    $DB'stop#'
        [$DB'line#'
         ] =~ s/;9$//;")
