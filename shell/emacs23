(:summary    "Specialized comint.el for running the shell"
 :created    "1988"
 :updated    "2011"
 :license    "GPL-3"
 :authors    (("Olin Shivers" . "shivers@cs.cmu.edu")
	      ("Simon Marshall" . "simon@gnu.org"))
 :maintainer ("FSF" . "emacs-devel@gnu.org")
 :provided   (shell)
 :required   ((("ansi-color" ansi-color)
	       ("comint" comint)))
 :keywords   ("processes")
 :wikipage   "http://www.emacswiki.org/ShellMode"
 :commentary "\
This file defines a shell-in-a-buffer package (shell mode) built on
top of comint mode.  This is actually cmushell with things renamed
to replace its counterpart in Emacs 18.  cmushell is more
featureful, robust, and uniform than the Emacs 18 version.

Since this mode is built on top of the general command-interpreter-in-
a-buffer mode (comint mode), it shares a common base functionality,
and a common set of bindings, with all modes derived from comint mode.
This makes these modes easier to use.

For documentation on the functionality provided by comint mode, and
the hooks available for customising it, see the file comint.el.
For further information on shell mode, see the comments below.

Needs fixin:
When sending text from a source file to a subprocess, the process-mark can
move off the window, so you can lose sight of the process interactions.
Maybe I should ensure the process mark is in the window when I send
text to the process? Switch selectable?

YOUR .EMACS FILE
=============================================================================
Some suggestions for your .emacs file.

;; Define M-# to run some strange command:
(eval-after-load \"shell\"
 '(define-key shell-mode-map \"\\M-#\" 'shells-dynamic-spell))

Brief Command Documentation:
============================================================================
Comint Mode Commands: (common to shell and all comint-derived modes)

m-p	   comint-previous-input    	   Cycle backwards in input history
m-n	   comint-next-input  	    	   Cycle forwards
m-r     comint-previous-matching-input  Previous input matching a regexp
m-s     comint-next-matching-input      Next input that matches
m-c-l   comint-show-output		   Show last batch of process output
return  comint-send-input
c-d	   comint-delchar-or-maybe-eof	   Delete char unless at end of buff.
c-c c-a comint-bol                      Beginning of line; skip prompt
c-c c-u comint-kill-input	    	   ^u
c-c c-w backward-kill-word    	   ^w
c-c c-c comint-interrupt-subjob 	   ^c
c-c c-z comint-stop-subjob	    	   ^z
c-c c-\\ comint-quit-subjob	    	   ^\\
c-c c-o comint-kill-output		   Delete last batch of process output
c-c c-r comint-show-output		   Show last batch of process output
c-c c-l comint-dynamic-list-input-ring  List input history
        send-invisible                  Read line w/o echo & send to proc
        comint-continue-subjob	   Useful if you accidentally suspend
					        top-level job
comint-mode-hook is the comint mode hook.

Shell Mode Commands:
        shell			Fires up the shell process
tab     comint-dynamic-complete	Complete filename/command/history
m-?     comint-dynamic-list-filename-completions
					List completions in help buffer
m-c-f   shell-forward-command	Forward a shell command
m-c-b   shell-backward-command	Backward a shell command
	   dirs				Resync the buffer's dir stack
	   shell-dirtrack-mode		Turn dir tracking on/off
        comint-strip-ctrl-m		Remove trailing ^Ms from output

The shell mode hook is shell-mode-hook
comint-prompt-regexp is initialised to shell-prompt-pattern, for backwards
compatibility.

Read the rest of this file for more information.")
